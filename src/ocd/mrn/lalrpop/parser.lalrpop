use crate::ocd::mrn::program::process_match_pattern;
use crate::ocd::mrn::program::process_replace_pattern;
use crate::ocd::mrn::program::{Instruction, InstructionError, Position, ReplaceArg};
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

extern {
    type Error = InstructionError;
}

Sequence<T>: Vec<T> = {
  <T> => vec![<>],
  <mut s:Sequence<T>> <n:T> => {
      s.push(n);
      s
  },
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Program = Comma<Operation>;

Operation: Instruction = {
    "s" => Instruction::Sanitize,
    "cl" => Instruction::CaseLower,
    "cu" => Instruction::CaseUpper,
    "ct" => Instruction::CaseTitle,
    "cs" => Instruction::CaseSentence,
    "jc" => Instruction::JoinCamel,
    "js" => Instruction::JoinSnake,
    "jk" => Instruction::JoinKebab,
    "sc" => Instruction::SplitCamel,
    "ss" => Instruction::SplitSnake,
    "sk" => Instruction::SplitKebab,
    "rdp" => Instruction::Replace{ pattern: ReplaceArg::Dash, replace: ReplaceArg::Period },
    "rds" => Instruction::Replace{ pattern: ReplaceArg::Dash, replace: ReplaceArg::Space },
    "rdu" => Instruction::Replace{ pattern: ReplaceArg::Dash, replace: ReplaceArg::Underscore },
    "rpd" => Instruction::Replace{ pattern: ReplaceArg::Period, replace: ReplaceArg::Dash },
    "rps" => Instruction::Replace{ pattern: ReplaceArg::Period, replace: ReplaceArg::Space },
    "rpu" => Instruction::Replace{ pattern: ReplaceArg::Period, replace: ReplaceArg::Underscore },
    "rsd" => Instruction::Replace{ pattern: ReplaceArg::Space, replace: ReplaceArg::Dash },
    "rsp" => Instruction::Replace{ pattern: ReplaceArg::Space, replace: ReplaceArg::Period },
    "rsu" => Instruction::Replace{ pattern: ReplaceArg::Space, replace: ReplaceArg::Underscore },
    "rud" => Instruction::Replace{ pattern: ReplaceArg::Underscore, replace: ReplaceArg::Dash },
    "rup" => Instruction::Replace{ pattern: ReplaceArg::Underscore, replace: ReplaceArg::Period },
    "rus" => Instruction::Replace{ pattern: ReplaceArg::Underscore, replace: ReplaceArg::Space },
    "r" <p:StringValue> <r:StringValue> => Instruction::Replace{ pattern: ReplaceArg::Text(p), replace: ReplaceArg::Text(r) },
    "i" <p:Position> <s:StringValue> => Instruction::Insert{position: p, text: s},
    "d" <f:Index> <t:Position> => Instruction::Delete{from: f, to: t},
    "ea" <e:StringValue> => Instruction::ExtensionAdd(e),
    "er" => Instruction::ExtensionRemove,
    "o" => Instruction::InteractiveReOrder,
    "p" <pattern:StringValue> <r:StringValue> => {
        let pattern = process_match_pattern(pattern);
        let replace = process_replace_pattern(r);
        Instruction::PatternMatch{ pattern, replace }
        },
}

// A position may either be the keyword 'end' or an index.
Position: Position = {
    "end" => Position::End,
    <i:Index> => Position::Index(i),
}

// An index is a non-negative integer.
Index: usize = {
    r"[0-9]+" =>? usize::from_str(<>).map_err(|error| {dbg!(error); ParseError::User{error: InstructionError::InvalidIndex}} )
};

// A string value is any apostrophes-bounded character sequence which does not include apostrophes.
StringValue: String = {
    <value: r"'[^']*'"> =>
        {
            value.trim_matches('\'').to_string()
        }
};
