use crate::ocd::mrn::program::process_match;
use crate::ocd::mrn::program::process_replace;
use crate::ocd::mrn::program::{Instruction, OcdParseError, Position, ReplaceArg};
use crate::ocd::mrn::lalrpop::tokens::Token;
use crate::ocd::mrn::lalrpop::tokens::LexicalError;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "stringvalue" => Token::StringValue(<String>),
        "index" => Token::Index(<usize>),
        "'" => Token::Apostrophe,
        "," => Token::Comma,
        "s" => Token::Sanitize,
        "cl" => Token::CaseLower,
        "cu" => Token::CaseUpper,
        "ct" => Token::CaseTitle,
        "cs" => Token::CaseSentence,
        "jc" => Token::JoinCamel,
        "js" => Token::JoinSnake,
        "jk" => Token::JoinKebab,
        "sc" => Token::SplitCamel,
        "ss" => Token::SplitSnake,
        "sk" => Token::SplitKebab,
        "rdp" => Token::ReplaceDashPeriod,
        "rds" => Token::ReplaceDashSpace,
        "rdu" => Token::ReplaceDashUnderscore,
        "rpd" => Token::ReplacePeriodDash,
        "rps" => Token::ReplacePeriodSpace,
        "rpu" => Token::ReplacePeriodUnderscore,
        "rsd" => Token::ReplaceSpaceDash,
        "rsp" => Token::ReplaceSpacePeriod,
        "rsu" => Token::ReplaceSpaceUnderscore,
        "rud" => Token::ReplaceUnderscoreDash,
        "rup" => Token::ReplaceUnderscorePeriod,
        "rus" => Token::ReplaceUnderscoreSpace,
        "r" => Token::Replace,
        "i" => Token::Insert,
        "end" => Token::End,
        "d" => Token::Delete,
        "ea" => Token::ExtensionAdd,
        "er" => Token::ExtensionRemove,
        "o" => Token::Reorder,
        "p" => Token::PatternMatch,
    }
}

Sequence<T>: Vec<T> = {
  <T> => vec![<>],
  <mut s:Sequence<T>> <n:T> => {
      s.push(n);
      s
  },
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Program = Comma<Operation>;

Operation: Instruction = {
    "s" => Instruction::Sanitize,
    "cl" => Instruction::CaseLower,
    "cu" => Instruction::CaseUpper,
    "ct" => Instruction::CaseTitle,
    "cs" => Instruction::CaseSentence,
    "jc" => Instruction::JoinCamel,
    "js" => Instruction::JoinSnake,
    "jk" => Instruction::JoinKebab,
    "sc" => Instruction::SplitCamel,
    "ss" => Instruction::SplitSnake,
    "sk" => Instruction::SplitKebab,
    "rdp" => Instruction::Replace{ pattern: ReplaceArg::Dash, replace: ReplaceArg::Period },
    "rds" => Instruction::Replace{ pattern: ReplaceArg::Dash, replace: ReplaceArg::Space },
    "rdu" => Instruction::Replace{ pattern: ReplaceArg::Dash, replace: ReplaceArg::Underscore },
    "rpd" => Instruction::Replace{ pattern: ReplaceArg::Period, replace: ReplaceArg::Dash },
    "rps" => Instruction::Replace{ pattern: ReplaceArg::Period, replace: ReplaceArg::Space },
    "rpu" => Instruction::Replace{ pattern: ReplaceArg::Period, replace: ReplaceArg::Underscore },
    "rsd" => Instruction::Replace{ pattern: ReplaceArg::Space, replace: ReplaceArg::Dash },
    "rsp" => Instruction::Replace{ pattern: ReplaceArg::Space, replace: ReplaceArg::Period },
    "rsu" => Instruction::Replace{ pattern: ReplaceArg::Space, replace: ReplaceArg::Underscore },
    "rud" => Instruction::Replace{ pattern: ReplaceArg::Underscore, replace: ReplaceArg::Dash },
    "rup" => Instruction::Replace{ pattern: ReplaceArg::Underscore, replace: ReplaceArg::Period },
    "rus" => Instruction::Replace{ pattern: ReplaceArg::Underscore, replace: ReplaceArg::Space },
    "r" <p:StringValue> <r:StringValue> => Instruction::Replace{ pattern: ReplaceArg::Text(p), replace: ReplaceArg::Text(r) },
    "i" <p:Position> <s:StringValue> => Instruction::Insert{position: p, text: s},
    "d" <f:"index"> <t:Position> => Instruction::Delete{from: f, to: t},
    "ea" <e:StringValue> => Instruction::ExtensionAdd(e),
    "er" => Instruction::ExtensionRemove,
    "o" => Instruction::Reorder,
    "p" <m:StringValue> <r:StringValue> => {
        let m = process_match(m);
        let r = process_replace(r);
        Instruction::PatternMatch{ match_pattern: m, replace_pattern: r }
        },
}

// A position may either be the keyword 'end' or an index.
Position: Position = {
    "end" => Position::End,
    <i:"index"> => Position::Index(i),
}

// An index is a non-negative integer.
/* no longer necessary to convert from string to usize and handle errors here
Index: usize = {
    <i:"index"> =>? {
        if let Token::Index(idx) = i {
            usize::from_str(idx).map_err(|error| {ParseError::User{error: OcdParseError::InvalidIndex}} )
        }
        else {
            Err(ParseError::User{error: OcdParseError::InvalidIndex})
        }
    }
};
*/

// A string value is any apostrophes-bounded character sequence which does not include apostrophes.
StringValue: String = {
    <value:"stringvalue"> => value.trim_matches('\'').to_string()
};
